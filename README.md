Weaver is an attempt at a high-level reimagining of the entire stack involved in the terminal, the shell, ssh, and everything involved in command-line interactions with network computers.

The general goal for weaver is to interact at a higher level with a single local program that runs commands on your behalf on many systems, both local and remote.  No more copying your shell files all over the world, no more discrepancies between local and remote accounts, or between users you've logged in as.  No more fighting about default shell configuration on shared admin accounts (root).  No more trying to arrange for your preferred shell to be installed on every system you ever use.  All shell parsing, logic, alias expansion, and extensions happen in a single local program, and input is compiled and interpreted into a representation of commands to be run on some host, and then Weaver takes care of arranging for the command to be run wherever appropriate.  You can keep records of all commands run and shell history in one place, rather than scattered across shell history files on N hosts and M users.

I plan to explore a variety of divergence from the traditional terminal and shell interaction model.  My first path of exploration here is a dedicated input text entry field, rather than mixing input and output into the same document.  This also opens up a variety of other affordances into interacting with program execution.  For example, you don't need to wait for program execution to complete before invoking another program.  You could launch a long-running grep in the background, and have it just add an entry to a monitoring or notification area showing progress, lines of output, completion, succcess/failure.  You can have all program output that's over a page long be automatically folded into a pager, and this output can be retained for later review on interaction with the program execution record in the history, rather than the fixed plain-text buffer of traditional shells.

I'd like to explore the space of programs that have the capability to run on and access data on all hosts you're logged into.  For example, copying files to or from your local system and the far end of a chain of ssh connections through bridge hosts.  With the traditional model, where each separate ssh invocation knows nothing about any of the others doesn't offer many capabilities to handle this use case.

I'd like to evaluate some divergences from the behaviour of traditional shells.  Some of this has certainly been explored with other shells, but it may be fun to explore myself, rather than reimplementing bash.

For now, I'm prototyping this with a TUI interface, but I plan to also experiment with a native GUI eventually, probably EFL.

I plan to try a few different models for handling command execution on remote hosts.  Sending text to a shell's stdin is certainly feasible, and will be my first pass, but there are some difficulties there and a few things tricky to get quite right.  I'd like to use this as an excuse to try cloud-haskell, and experiment with a mode that copies Weaver (or a subset) into the remote host and runs it there.  This is clearly a terrible idea for a variety of reasons, but would be fun to try.

I'd like to try experimenting with transparently providing additional capabilities to other native programs run through Weaver.  For example, I could expose a remote system's filesystem locally over a FUSE mount in a separate mount namespace, which might be kind of sane depending on what I export, or I could do the horrible insane option and hook into the program through ptrace(2).

To build weaver, make sure you have stack installed, and run 'stack build'.
